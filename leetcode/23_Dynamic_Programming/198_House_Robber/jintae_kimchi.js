/**
 * https://leetcode.com/problems/house-robber/
 * rob
 * Runtime: 83 ms, faster than 58.38% of JavaScript online submissions for House Robber.
 * Memory Usage: 42.2 MB, less than 33.39% of JavaScript online submissions for House Robber.
 * 메모리 성능이 낮게 나왔는데 원인을 분석해보면 추가배열 없이 하는 방법이 있었다. solution 매서드로 구현함
 *
 *
 * 로직을 떠올린 과정
 * [8 7 6 5 4 3 2 1]을 테스트케이스로 준비함
 * => 배열의 모든 요소를 한번은 순회해야한다
 * => 특정 인덱스 기준으로 잡고 다음에 올 수 있는 요소를 나열해본다
 * => 다음에 오는 요소도 그 다음에 올 수 있는 요소들이 있을 것이다.
 * => 재귀적으로 반복하면 끝까지 탐색한 결과들이 나온다 (일단은 브루트 포스로 보임)
 * => 그 중 가장 누적값이 큰 것을 고른다
 *
 *  8 => [6 5 4 3 2 1]
 *    6 => [4 3 2 1]    // 8-6
 *      4 => [2 1]      // 8-6-4
 *        2 => []       // 8-6-4-2
 *        1 => []       // 8-6-4-1
 *      3 => [1]        // 8-6-3-1
 *      2 => []         // 8-6-2
 *      1 => []         // 8-6-1
 *    5 => [3 2 1]      // 8-5
 *      3 => [1]        // 8-5-3
 *      2 => []         // 8-5-2
 *      1 => []         // 8-5-1
 *    4 => [2 1]        // 8-4
 *      2 => []         // 8-4-2
 *      1 => []         // 8-4-1
 *    3 => [1]          // 8-3-1
 *    2 => []           // 8-2
 *    1 => []           // 8-1
 *  7 => [5 4 3 2 1]
 *    5 => [3 2 1]      // 7-5
 *      3 => [1]        // 7-5-3
 *      2 => []         // 7-5-2
 *      1 => []         // 7-5-1
 *    4 => [2 1]        // 7-4
 *      2               // 7-4-2
 *      1               // 7-4-1
 *    3 => [1]          // 7-3-1
 *    2 => []           // 7-2
 *    1 => []           // 7-1
 *  6 => [4 3 2 1]      // 8 에 있음
 *  5 => [3 2 1]        // 8, 7 에 있음
 *  4 => [2 1]          // ...
 *  3 => [1]
 *  2 => []
 *  1 => []
 *
 * => 직접 모든 케이스를 나열해보면 첫번째 또는 두번째 요소를 시작으로 하는 케이스가 나머지 케이스를 부분집합으로 가지는 것을 확인할 수 있음
 * => 탐색이 끝날때 누적값을 최대값으로 갱신하면 됨
 * => 트리로 나열해보니 중복탐색이 많은 구조임을 알 수 있었고 이걸 메모할 수 있는 방법을 구현하게 내가 구현한 코드임
 *
 *
 * => 설명을 위해 다시 분석해보면 최소케이스를 메모하면 더 상위케이스를 바로 계산할 수 있는 것을 알 수 있었음
 * => 아래는 이를 정리해본 것
 *
 * f(1) = (1 => []) = 1
 * f(2) = (2 => []) = 2
 * f(3) = (3 => [1])
 *      = 3 + f(1) = 4
 *
 * // 여기까지는 결과가 명확한 케이스이므로 조합을 위한 기본 재료준비라고 볼 수 있음
 *
 * f(4) = 4 => [2 1]            // 4일때 2, 1 두 가지의 조합이 가능함
 *      = [4 + f(2), 4 + f(1)]  // 모든 결과를 계산해봄
 *      = (4 + 2), (4 + 1)
 *      = [6, 5] = 6            // 모든 결과 중 가장 큰 값을 취하여 현재 요소와 더하면 f(4)에서 나올 수 있는 최대값임
 *
 * f(5) = 5 => [3 2 1]
 *      = [5 + f(3), 5 + f(2), 5 + f(1)]
 *      = [9, 7, 6] = 9
 *
 * // 여기까지 해보면 하위 케이스의 최대값과 현재 값을 더하면 되는 것을 알 수 있다
 *
 * f(6) = 6 => [4 3 2 1]
 *      = 6 + max(f(4), f(3), f(2), f(1))
 *      = 6 + 6 = 12
 * f(7) = 7 => [5 4 3 2 1]
 *      = 7 + max(f(5), f(4), f(3), f(2), f(1))
 *      = 7 + 9 = 16
 * f(8) = 8 => [6 5 4 3 2 1]
 *      = 8 + max(f(6), f(5), f(4), f(3), f(2), f(1))
 *      = 8 + 12 = 20
 *
 * f(n) = n + max(f(n - 2), f(n - 3), ... , f(1))
 *
 * [2, 7, 9, 1, 1, 5, 8, 2] 일 때는?
 * f(1) = 2
 * f(2) = 8
 * f(3) = 7
 * f(4) = 1 + max(f(2) ~ f(1)) = 9
 * f(5) = 1 + max(f(3) ~ f(1)) = 9
 * f(6) = 9 + max(f(4) ~ f(1)) = 18
 * f(7) = 7 + max(f(5) ~ f(1)) = 16
 * f(8) = 2 + max(f(6) ~ f(1)) = 20
 *
 * 최대값으로 나열하면
 * f(8) = 20, f(6) = 18, f(7) = 16 이다
 * 그런데 f(6)은 f(8)의 하위 셋이므로 max(f(8), f(7)) = 20이 된다.
 *
 * 이 개념을 인덱스만 반대로 하면 솔루션의 코드가 됨
 * f(1) = 첫번째 요소
 * f(2) = 두번째 요소
 * f(3) = 세번째 요소 + max(f(3 - 2), ..., f(1))
 * f(n) = n번째 요소 + max(f(n - 2), ..., f(1))
 */

/**
 * index가 연속되지 않은 요소들을 추출하여 만들 수 있는 가장 큰 값을 계산
 * @param {number[]} nums
 * @return {number}
 */
var rob = function (nums) {
  let ans = 0;
  const maxNums = nums.map((n) => {
    ans = Math.max(ans, n);
    return n;
  });
  for (let i = 0; i < nums.length; i++) {
    const curr = maxNums[i];
    for (let j = i + 2; j < nums.length; j++) {
      const next = nums[j];
      const val = curr + next;
      ans = Math.max(ans, val);
      maxNums[j] = Math.max(maxNums[j], val);
    }
  }

  return ans;
};

/**
 * 3개의 초기 케이스를 잡고 선택적으로 최대값을 갱신해주면 마지막 요소 홀짝 중 하나가 최대값임
 * [2, 7, 9, 3, 1, 5, 8, 2]
 *  2, 7,11                 // 초기 케이스. 첫번째 두번째는 네번째 값과 더할 대상, 9는 2화 더하는게 최대값이라 11
 *  2  7     3              // 3에 2와 7중 더 큰값을 더하여 배열에 누적함
 *     7 11 10              // 다음 케이스를 위한 값이 세팅됨 이제부터 반복
 *     7 11     1           // max(7, 9) + 1 = 10
 *       11 10 12
 *          10 12 16
 *             12 16 20
 *                16 20 18 // ans is max(20, 18)
 *
 * Runtime: 87 ms, faster than 51.58% of JavaScript online submissions for House Robber.
 * Memory Usage: 41.6 MB, less than 93.29% of JavaScript online submissions for House Robber.
 * @param {number[]} nums
 * @return {number}
 */
const solution = (nums) => {
  let x = nums[0] || 0;
  let y = nums[1] || 0;
  if (nums.length < 3) return Math.max(x, y);
  let z = x + nums[2];
  for (let i = 3; i < nums.length; i++) {
    const curr = Math.max(x, y) + nums[i];
    x = y;
    y = z;
    z = curr;
  }

  return Math.max(y, z);
};

const { runTestCase } = require("../../utils");
runTestCase(
  [
    {
      params: [[2, 7, 9, 3, 1, 5, 8, 2]],
      expect: 20,
    },
    {
      params: [[1]],
      expect: 1,
    },
    {
      params: [[1, 2, 3, 1]],
      expect: 4,
    },
    {
      params: [[2, 7, 9, 3, 1]],
      expect: 12,
    },
  ],
  solution
);
