# 4sum

## 📝 문제 (Problem)

- 링크: https://leetcode.com/problems/4sum/description/
- 난이도: Medium

---

## 🤔 나의 첫 접근 (My First Approach)

3sum + a 라고 직감적으로 생각.
a, b, c 포인터로 합계를 찾는 방식이었으니
a, (b1, b2), c 로 생각하면 같은 문제일 것이라 생각
결과적으로 4개의 포인터를 이용한 접근을 하게 됨.

---

## 🤯 내가 막혔던 부분 (The Bottleneck)

4개의 포인터로 로직을 작성하니 제어가 쉽지 않았음.
솔루션을 보고 2개의 for문으로 감싸고 3sum 을 작성하였는데, 여전히 시간 내에 중복값 제어하지 못함.
(중복 값 처리에 대한 정확한 이해 없이 풀려고 함)

---

## 💡 핵심 아이디어 & 패턴 (Core Idea & Pattern)

Nsum -> 3sum -> 2sum 으로 축소해서 처리
2sum 만 포인터처리를 하는거고 나머지는 반복문임

- 패턴 이름: k-Sum 문제 해결 패턴
- 전략: '문제 차원 축소' 와 '투 포인터' 의 조합
  1. 4Sum 문제를 for 루프로 숫자 하나(a)를 고정시켜, b + c + d = target - a를 찾는 3Sum 문제로 변환한다.
  2. 3Sum 문제 역시 for 루프로 숫자 하나(b)를 고정시켜, c + d = target - a - b를 찾는 2Sum 문제로 변환한다.
  3. 정렬된 배열에서의 2Sum 문제는 투 포인터로 O(N)에 해결한다.
- 최종 시간 복잡도: O(N³) (이중 for문 O(N²) \* 투 포인터 O(N))

---

## 🧐 '왜?'에 대한 분석 (The 'Why' Analysis)

- Q. 왜 가장 먼저 '정렬'을 해야 하는가?
  - 정렬이 되어 있어야 값을 증가/감소할 수 있음. (증가:왼쪽++, 감소: 오른쪽--)
- Q. 왜 바깥쪽 for 루프의 중복은 '탐색 시작 전'에 건너뛰는가?
  - 첫 번째 케이스를 실행해보고 다음 케이스가 왔을 때 이전 케이스와 동일한 지 검사하여 동일하면 넘어가기 위해
- Q. 왜 안쪽 투 포인터의 중복은 '정답을 찾은 후'에 건너뛰는가?

  ```plaintext
  two pointer 문제로 단순화 하여 생각하면
  [1, 2, 3(a), 3, 3, 3, 3, 3, 4(b), 5, 6], target = 6

  선 계산 시
    [1, 2, 3(a), 3, 3, 3, 3, 3, 4(b), 5, 6] // 3 + 4
  sum > target
    [1, 2, 3(a), 3, 3, 3, 3, 3(b), 4, 5, 6] // b 값만 감소시켜야 함 3, 3케이스 확인 가능

  선 감소 시
    [1, 2, 3, 3, 3, 3, 3, 3(a), 4(b), 5, 6] // 중복처리, 3 + 4
  sum > target <------문제되는 케이스
    [1, 2, 3, 3, 3, 3, 3, 3(ab), 4, 5, 6] // b를 감소시켜야 함. 근데 탐색이 종료됨 3,3 케이스 확인 불가
  ```

---

## 🏷️ 태그 (Tags)

Array
Two Pointers
Sorting
