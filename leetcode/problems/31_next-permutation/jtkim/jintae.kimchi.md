네, 그럼요. "Next Permutation" 문제에 대한 전체 리뷰와 학습 과정을 하나의 정리된 문서로 만들어 드릴게요. 이 노트를 통해 앞으로 비슷한 문제를 만났을 때 자신감을 갖고 해결하실 수 있을 겁니다.

---

## **알고리즘 문제 회고: Next Permutation**

### **1. 문제 정보**

- **문제:** Next Permutation ([Link](https://leetcode.com/problems/next-permutation/description/))
- **난이도:** Medium

### **2. 나의 첫 도전과 고민**

처음 문제를 접했을 때 "사전 순으로 다음에 오는 순열을 찾으라"는 요구사항을 파악했다. 모든 순열을 생성하고 현재 순열 다음 것을 찾는 브루트 포스 방식은 시간 초과가 날 것이라 예상하고, `[1, 4, 2, 5, 3]` -\> `[1, 4, 3, 2, 5]`와 같은 예시를 통해 값 변경의 규칙을 찾으려 했다.

하지만 여러 개의 포인터를 직접 제어하여 규칙을 만들려는 시도는 로직이 너무 복잡해져 길을 잃었고, 특히 중복 값이 있는 케이스는 어떻게 처리해야 할지 막막했다. 또한 "in-place" 제약 조건을 "배열을 수정하면 안 된다"고 오해하여 접근에 어려움을 겪었다.

### **3. 핵심 해결 전략 (4단계 알고리즘)**

이 문제의 핵심은 "현재 순서보다 아주 약간만 더 큰 순서를 만들기 위해, **변화는 최대한 오른쪽(낮은 자릿수)에서 시작되어야 한다**"는 아이디어에서 출발한다.

#### **1단계: 기준점(Pivot) 찾기**

배열을 **오른쪽에서 왼쪽으로** 탐색하며, `nums[i] < nums[i+1]`이 성립하는 첫 번째 `i`를 찾는다. 이 `i` 위치의 값이 바로 변화가 시작될 기준점(Pivot)이다.

- **예시:** `[1, 4, | 2, | 5, 3]`
  - `3 < 5` (X), `5 > 2` (X), `2 < 4` (O) -\> `i`는 `2`의 위치.
  - `i`의 오른쪽 부분(`[5, 3]`)은 이미 내림차순이라 자체적으로 더 큰 순서를 만들 수 없으므로, 변화는 반드시 `i` 또는 그 왼쪽에서 일어나야 한다.

#### **2단계: 교체할 숫자(Successor) 찾기**

`i`의 오른쪽 부분에서, 기준점 `nums[i]`보다 **크면서 가장 작은 값**을 찾는다. 이 값이 교체할 숫자(Successor)가 된다.

- **예시:** 기준점 `2`의 오른쪽 `[5, 3]`에서 `2`보다 크면서 가장 작은 값은 `3`이다.

#### **3단계: 교체 (Swap)**

1단계에서 찾은 기준점(`nums[i]`)과 2단계에서 찾은 교체할 숫자(`nums[j]`)를 맞바꾼다.

- **예시:** `[1, 4, 2, 5, 3]` -\> `[1, 4, 3, 5, 2]`

#### **4단계: 뒷부분 뒤집기 (Reverse)**

3단계까지 마치면, `i`의 뒷부분은 내림차순으로 정렬된 상태를 유지한다. 이 부분을 **가장 작은 순서(오름차순)로** 만들어야 전체적으로 다음 순서가 완성된다. 내림차순을 오름차순으로 만드는 가장 효율적인 방법은 **배열을 뒤집는(Reverse)** 것이다.

- **예시:** `[1, 4, 3, | 5, 2]` -\> `[5, 2]`를 뒤집으면 `[2, 5]`.
- **최종 결과:** `[1, 4, 3, 2, 5]`

#### **※ 예외 케이스: 마지막 순열**

만약 `[4, 3, 2, 1]`처럼 배열 전체가 내림차순이라 1단계의 기준점을 찾을 수 없다면(`i`가 `-1`이 됨), 이미 가장 큰 순열이므로 문제의 요구사항에 따라 배열 전체를 뒤집어 가장 작은 순열(`[1, 2, 3, 4]`)로 만든다.

### **4. 주요 함정과 깨달음**

- **Sort vs. Reverse:** 4단계에서 O(N log N)의 `sort` 대신 O(N)의 `reverse`를 사용하는 것이 이 문제의 핵심 최적화 포인트였다. 기준점 뒤는 항상 내림차순이라는 특성을 활용해야 했다.
- **중복 값 처리:** 알고리즘의 모든 비교 조건이 등호 없는 부등호(`<`, `>`)를 사용하므로, `[4, 2, 2, 1]` 같은 중복 케이스도 별도의 처리 없이 자연스럽게 해결된다는 것을 깨달았다.
- **재귀 vs. 반복문:** 내가 처음 풀었던 재귀 방식의 `search(idx-1)` 호출은, `for (i = n-2; i >= 0; i--)` 반복문의 `i--`와 논리적으로 동일했다. 재귀로 구현한 로직을 반복문으로 전환하는 연습을 통해 사고를 확장할 수 있었다.

### **5. 최종 코드 (정석 풀이)**

```javascript
function nextPermutation(nums: number[]): void {
  if (nums.length < 2) return;

  // 1. 기준점(pivot) 찾기 (오른쪽 -> 왼쪽)
  let i = nums.length - 2;
  while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
  }

  if (i >= 0) {
    // 2. 교체할 숫자(successor) 찾기 (오른쪽 -> 왼쪽)
    let j = nums.length - 1;
    while (nums[j] <= nums[i]) {
      j--;
    }
    // 3. 교체 (Swap)
    [nums[i], nums[j]] = [nums[j], nums[i]];
  }

  // 4. 뒷부분 뒤집기 (Reverse)
  let left = i + 1;
  let right = nums.length - 1;
  while (left < right) {
    [nums[left], nums[right]] = [nums[right], nums[left]];
    left++;
    right--;
  }
}
```

### **6. 마치며**

초기 접근의 어려움을 딛고, 단계별 힌트를 통해 핵심 규칙을 발견하고 최적화까지 이끌어낸 중요한 문제였다. 처음에는 보이지 않던 규칙을 논리적으로 분해하고, 예외 케이스를 처리하는 과정에서 한 단계 성장할 수 있었다. 이 패턴은 배열 문제의 핵심 유형 중 하나로 반드시 기억해 둘 가치가 있다.
